/**
 * Question Database Service (Server-side)
 * JSON-based storage for questions (no native dependencies)
 */

import path from 'path';
import fs from 'fs/promises';
import fsSync from 'fs';

interface QuestionRecord {
  id: string;
  question: string;
  options?: string[];
  correct_answer?: number;
  explanation?: string;
  subject: string;
  difficulty?: string;
  time_to_solve?: number;
  exam_type?: string;
  year?: number;
  paper_name?: string;
  topics?: string[];
  metadata?: any;
  created_at: string;
}

export class QuestionDatabase {
  private dbPath: string;
  private questions: QuestionRecord[] = [];
  private loaded: boolean = false;

  constructor() {
    this.dbPath = process.env.DB_PATH || './data/questions.json';
    
    // Ensure directory exists
    const dir = path.dirname(this.dbPath);
    if (!fsSync.existsSync(dir)) {
      fsSync.mkdirSync(dir, { recursive: true });
    }

    this.loadData();
  }

  private loadData() {
    try {
      if (fsSync.existsSync(this.dbPath)) {
        const data = fsSync.readFileSync(this.dbPath, 'utf-8');
        this.questions = JSON.parse(data);
      } else {
        this.questions = [];
        this.saveData();
      }
      this.loaded = true;
    } catch (error) {
      console.error('Error loading database:', error);
      this.questions = [];
      this.loaded = true;
    }
  }

  private async saveData() {
    try {
      await fs.writeFile(this.dbPath, JSON.stringify(this.questions, null, 2), 'utf-8');
    } catch (error) {
      console.error('Error saving database:', error);
    }
  }

  async importQuestions(results: any): Promise<void> {
    const insert = this.db.prepare(`
      INSERT OR REPLACE INTO questions (
        id, question, options, correct_answer, explanation, 
        subject, difficulty, time_to_solve, exam_type, year, 
        paper_name, topics, metadata
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    const transaction = this.db.transaction((questions: any[]) => {
      for (const q of questions) {
        insert.run(
          q.questionId,
          q.questionText.translated || q.questionText.original,
          JSON.stringify(q.options?.map((o: any) => o.text.translated || o.text.original)),
          q.correctAnswer,
          q.explanation?.translated || q.explanation?.original || '',
          q.subject,
          q.difficulty,
          q.timeToSolve,
          q.metadata.examType,
          q.metadata.year,
          q.metadata.paperName,
          JSON.stringify(q.topics || []),
          JSON.stringify(q.metadata)
        );
      }
    });

    transaction(results.extractedQuestions);
  }

  async getQuestions(filters: any): Promise<any[]> {
    let filtered = [...this.questions];

    if (filters.examTypes && filters.examTypes.length > 0) {
      filtered = filtered.filter(q => filters.examTypes.includes(q.exam_type));
    }

    if (filters.subjects && filters.subjects.length > 0) {
      filtered = filtered.filter(q => filters.subjects.includes(q.subject));
    }

    if (filters.years && filters.years.length > 0) {
      filtered = filtered.filter(q => filters.years.includes(q.year));
    }

    if (filters.difficulties && filters.difficulties.length > 0) {
      filtered = filtered.filter(q => filters.difficulties.includes(q.difficulty));
    }

    const limit = filters.limit || 50;
    const offset = filters.offset || 0;
    
    return filtered.slice(offset, offset + limit).map(this.formatQuestion);
  }

  async getQuestionById(id: string): Promise<any> {
    const row = this.db.prepare('SELECT * FROM questions WHERE id = ?').get(id);
    return row ? this.formatQuestion(row) : null;
  }

  async searchQuestions(query: string, filters: any = {}): Promise<any[]> {
    // Full-text search
    let sqquestion = this.questions.find(q => q.id === id);
    return question ? this.formatQuestion(question
      JOIN questions_fts fts ON q.rowid = fts.rowid
      WHERE questions_fts MATCH ?
    `;
    const params: any[] = [query];

    if (filters.examTypes) {
      sql += ` AND exam_type IN (${filters.examTypes.map(() => '?').join(',')})`;
      params.push(...filters.examTypes);
    }

    if (filters.subjects) {
      sql += ` AND subject IN (${filters.subjects.map(() => '?').join(',')})`;
      params.push(...filters.subjects);
    }

    sql += ' LIMIT 100';

    const rows = this.db.prepare(sql).all(...params);
    return rows.map(this.formatQuestion);
  }

  async countQuestions(filters: any): Promise<number> {
    let filtered = [...this.questions];

    if (filters.examTypes && filters.examTypes.length > 0) {
      filtered = filtered.filter(q => filters.examTypes.includes(q.exam_type));
    }

    if (filters.subjects && filters.subjects.length > 0) {
      filtered = filtered.filter(q => filters.subjects.includes(q.subject));
    }

    return filtered.length;
  }

  async getExamTypes(): Promise<string[]> {
    const rows = this.db.prepare('SELECT DISTINCT exam_type FROM questions ORDER BY exam_type').all();
    return rows.map((r: any) => r.exam_type).filter(Boolean);
  }

  async getypes = [...new Set(this.questions.map(q => q.exam_type).filter(Boolean))];
    return types.sort(
      ? 'SELECT DISTINCT subject FROM questions WHERE exam_type = ? ORDER BY subject'
      : 'SELECT DISTINCT subject FROM questions ORDER BY subject';
    
    const filtered = examType 
      ? this.questions.filter(q => q.exam_type === examType)
      : this.questions;
    
    const subjects = [...new Set(filtered.map(q => q.subject))];
    return subjects.sort(
      ? 'Sfiltered = examType 
      ? this.questions.filter(q => q.exam_type === examType && q.year)
      : this.questions.filter(q => q.year);
    
    const years = [...new Set(filtered.map(q => q.year!))];
    return years.sort((a, b) => b - a

  async generateTest(request: any): Promise<any> {
    const questions = await this.getQuestions({
      ...request.filters,
      limit: request.count * 2, // Get more for randomization
      offset: 0,
    });

    // Randomize if requested
    let selectedQuestions = questions;
    if (request.randomize) {
      selectedQuestions = questions.sort(() => Math.random() - 0.5);
    }

    selectedQuestions = selectedQuestions.slice(0, request.count);

    return {
      id: `test_${Date.now()}`,
      name: this.generateTestName(request),
      testType: request.testType,
      questions: selectedQuestions,
      duration: request.duration || this.estimateDuration(selectedQuestions),
      totalMarks: selectedQuestions.length,
      metadata: {
        filters: request.filters,
        generatedAt: new Date().toISOString(),
      },
    };
  }

  async getStatistics(): Promise<any> {
    const stats = this.db.prepare(`
      SELECT 
        COtotal_questions = this.questions.length;
    const total_exams = new Set(this.questions.map(q => q.exam_type).filter(Boolean)).size;
    const total_subjects = new Set(this.questions.map(q => q.subject)).size;
    const total_years = new Set(this.questions.map(q => q.year).filter(Boolean)).size;

    const examTypeCounts = new Map<string, number>();
    const subjectCounts = new Map<string, number>();
    const difficultyCounts = new Map<string, number>();

    this.questions.forEach(q => {
      if (q.exam_type) {
        examTypeCounts.set(q.exam_type, (examTypeCounts.get(q.exam_type) || 0) + 1);
      }
      if (q.subject) {
        subjectCounts.set(q.subject, (subjectCounts.get(q.subject) || 0) + 1);
      }
      if (q.difficulty) {
        difficultyCounts.set(q.difficulty, (difficultyCounts.get(q.difficulty) || 0) + 1);
      }
    });

    return {
      total_questions,
      total_exams,
      total_subjects,
      total_years,
      byExamType: Array.from(examTypeCounts.entries()).map(([exam_type, count]) => ({ exam_type, count })),
      bySubject: Array.from(subjectCounts.entries()).map(([subject, count]) => ({ subject, count })),
      byDifficulty: Array.from(difficultyCounts.entries()).map(([difficulty, count]) => ({ difficulty, count }))

  async getExamStatistics(examType: string): Promise<any> {
    const stats = this.db.prepare(`
      SELECT 
        COUNT(*) as total_questions,
        COUNT(DISTINCT subject) as total_subjects,
        COUNT(DISTINCT year) as total_years
      FROM questions
      WHERE exam_type = ?
    `).getfiltered = this.questions.filter(q => q.exam_type === examType);
    
    return {
      total_questions: filtered.length,
      total_subjects: new Set(filtered.map(q => q.subject)).size,
      total_years: new Set(filtered.map(q => q.year).filter(Boolean)).size,
    }STINCT exam_type) as total_exams
      FROM questions
      WHERE subject = ?
    `).get(subject);

    return stats;
  }

  private formatQuestion(row: any): any {
    return {
      id: row.id,
      question: row.question,
      options: row.options ? JSON.parse(row.options) : [],
      correctAnswer: row.correct_answer,
      explanation: row.explanation,
      subject: row.subject,
      difficulty: row.difficulty,
      timeToSolve: row.time_to_solve,
      metadata: {
        examType: row.exam_type,
        year: row.year,
        paperName: row.paper_name,
        topics: row.topics ? JSON.parse(row.topics) : [],
      },
    };
  }

  private generateTestName(request: any): string {
    const parts: string[] = [];

    if (request.filters.examTypes?.length === 1) {
      parts.push(request.filters.examTypes[0]);
    }

    if (request.filters.years?.length === 1) {
      parts.push(request.filters.years[0].toString());
    }

    if (request.filters.subjects?.length === 1) {
      parts.push(request.filters.subjects[0]);
    }

    if (parts.length === 0) {
      parts.push(request.testType.replace('_', ' '));
    }

    return parts.join(' - ');
  }

  private estimateDuration(questions: any[]): number {
    const totalTime = questions.reduce((sum, q) => sum + (q.timeToSolve || 60), 0);
    return Math.ceil(totalTime / 60);
  }

  close() {
    this.db.close();
  }
}
// No-op for JSON storage, but kept for compatibility